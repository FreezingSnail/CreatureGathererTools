# PokerVM binary-file format  
*(header still **TBD**)*

This document describes the on-disk layout generated by the script
assembler and consumed by the VM running from SPI-flash.

The file contains two mandatory blocks, laid out back-to-back.  
Whether a fixed header precedes them is **undecided**; all offsets below
are expressed relative to the beginning of their respective block, so a
future header will not invalidate the math.

```
┌───────────────┬───────────────────────────────┬───────────────────────┐
│   (header?)   │           Text block          │    Byte-code block    │
│     TBD       │  (offset table + ASCII blob)  │  (256-byte chunks)    │
└───────────────┴───────────────────────────────┴───────────────────────┘
```

After assembly the file length is always a multiple of 256 bytes because
the text block is padded with `0x00` until the next 256-byte boundary;
the byte-code block therefore starts on such a boundary no matter how
long the optional header becomes.

----------------------------------------------------------------------
## 1. Text block

Holds every printable message referenced from byte-code.

```
┌──────────────────────────────┬───────────────────────────────┐
│ Offset table  (N + 1 × 3 B)  │       ASCII text blob         │
└──────────────────────────────┴───────────────────────────────┘
0x00                           base + (N+1)·3
```

### 1.1 Offset table (24-bit little-endian)

Entry            | Size  | Meaning
---------------- | ----- | ----------------------------------------------
`offset[0] … offset[N]` | `(N+1) × 3 B` | Byte position—relative to the first byte of the **text blob**—where message *i* starts. The final entry `offset[N]` equals the blob length and allows the VM to compute `len = offset[i+1] − offset[i]`.

* Numerical message IDs used in byte-code equal the array indices.
* 24-bit addresses cover up to 16 MiB (`0x00_0000 … 0xFF_FFFF`).
* Little-endian byte order: `lo, mid, hi`.

### 1.2 ASCII text blob

* Raw 7-bit ASCII (`0x20 … 0x7E`) concatenated without separators.
* No terminators; length derived from consecutive offsets.
* After the last character the assembler pads with `0x00` until the
  overall file position is divisible by 256.

### 1.3 SPI read sequence (firmware side)

```
table_addr = text_block_base + id × 3
start = read_24bit_LE(table_addr)
end   = read_24bit_LE(table_addr + 3)
length = end - start
stream 'length' bytes from (text_blob_base + start)
```

----------------------------------------------------------------------
## 2. Byte-code block

Directly follows the padded text block and occupies the remainder of the
file.  It is an array of **256-byte chunks**; each map chunk has one
corresponding byte-code chunk.

### 2.1 Chunk layout (no per-chunk header)

```
Offset 0x00 … 0xFF  (256 bytes total)
+-------------------------------------------------------------+
| script #0 ... 0xFF | script #1 ... 0xFF | … | 00 00 … 00    |
+-------------------------------------------------------------+
```

Rules  
1. Every script ends with sentinel opcode **`0xFF`** (`END_SCRIPT`).  
2. After the final script the remaining bytes are **`0x00`** padding.  
3. Total of all script bytes + `0xFF` sentinels ≤ 256.

### 2.2 VM execution loop for one chunk

```
pos = chunk_start
loop:
    op = *pos
    if op == 0x00           // reached padding → done with chunk
        break
    run_script_from(pos)    // interpret until 0xFF
    pos = byte_after_that_0xFF
```

### 2.3 Address calculation

With `bytecode_base` = first byte of the byte-code block:

```
chunk_start = bytecode_base + chunk_index × 256
```

If a header is later introduced, its fixed size or an explicit pointer
must let the VM compute `bytecode_base`; everything else remains valid.

----------------------------------------------------------------------
## 3. Opcode set (draft)

Opcode | Name          | Operand bytes (little-endian)           | Note
------ | ------------- | --------------------------------------- | ----
0x01   | MSG           | tile(u16)  text_id(u24)                 | `text_id` fits `offset[i]` row.
0x02   | TMSG_TAG      | tag_id(u8)  text_id(u24)                |
0x03   | TMSG_CORD     | x(u8) y(u8)  text_id(u24)               |
0x10   | SET_FLAG      | flag_id(u8)                             |
0x11   | UNSET_FLAG    | flag_id(u8)                             |
0x12   | READ_FLAG     | flag_id(u8)                             |
0xFE   | NOP / reserved| –                                       |
0xFF   | END_SCRIPT    | –                                       |

----------------------------------------------------------------------
## 4. Open questions (TBD)

| Topic                                             | Status |
| ------------------------------------------------- | ------ |
| Presence & exact layout of a global file header   | TBD |
| Placement of tag/flag lookup tables               | TBD |
| Compression options for the text blob             | TBD |
| Endianness of multi-byte operands (assumed little)| TBD |

These unresolved points can be finalised later without changing the
constant-size chunk structure or the 24-bit text offset table.

## 5. Potential improvements  (TODO / under consideration)

These items are **not** part of today's spec; they are recorded here for
future evaluation.

### 5.1 Smaller byte-code operands (idea #3)

Store full 24-bit text offsets only in the **offset table**; let op-codes
carry a **table index** instead:

* 8-bit index   → ≤ 255 strings, MSG-like op-codes shrink by 1 byte.  
* 16-bit index  → ≤ 65 536 strings, still 1 byte smaller than a 24-bit
  offset.

The assembler would translate indices to offsets at link time; the VM
performs one extra table lookup when fetching the string.

### 5.2 Skipping empty byte-code chunks (idea #5)

Large maps often contain many 256-byte chunks filled only with `0x00`
padding. Two options to avoid pointless SPI reads:

1. **Bitset directory** – one bit per chunk indicating “contains code”.
2. **Run-length table** – pairs of (count, presence) for consecutive
   identical regions.

Both keep constant-time math for non-empty chunks while allowing the VM
to jump over empty space quickly.

### 5.3 Forward-compatibility helpers (idea #7)

* Reserve opcode `0xFD` as an “EXTENDED” escape for future multi-byte
  op-codes.
* Consider a minimal 4–8 byte file header containing:  
  – magic, version, feature-flag bits, optional CRC.  
  This lets new firmware versions detect incompatible images early.

These enhancements can be introduced later without breaking the current
two-block structure or the 256-byte chunk alignment.