//! High-level AST for one script *before* it is lowered to byte-code.

#[derive(Debug, Clone, PartialEq)]
pub struct Text {
    pub text: String,
    pub index: u16, // numeric id assigned by the parser
}

/* ------------------------------------------------------------------------- */
/*  Opcodes                                                                  */
/* ------------------------------------------------------------------------- */

/// One-byte discriminant that uniquely identifies the command variant inside
/// the generated byte-code stream.
///
/// NOTE: The numeric values **must stay in sync** with the order of
/// `Cmd::VARIANT_NAMES` because external tooling may rely on that mapping.
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Opcode {
    Msg = 0,
    TMsg = 1,
    Tp = 2,
    If = 3,
    SetFlag = 4,
    UnsetFlag = 5,
    ReadFlag = 6,
    End = 7,
}

impl From<Opcode> for u8 {
    #[inline(always)]
    fn from(op: Opcode) -> Self {
        op as u8
    }
}

/* ------------------------------------------------------------------------- */
/*  AST nodes                                                                */
/* ------------------------------------------------------------------------- */

#[derive(Debug, Clone, PartialEq)]
pub enum Location {
    Cords(u16, u16),
    Tag(Text), // ← uses Text now
}

#[derive(Debug, Clone, PartialEq)]
pub enum Branch {
    ThenElse(Box<Cmd>, Box<Cmd>),
    Then(Box<Cmd>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Condition {
    FlagSet(Text),   // flag_X
    FlagClear(Text), // !flag_X
}

#[derive(Debug, Clone, PartialEq)]
pub enum Cmd {
    /// `msg {text}`
    Msg {
        text: Text,
    },

    /// `tmsg @loc {text}`
    TMsg {
        at: Location,
        text: Text,
    },

    /// `tp …`
    Tp {
        from: Location,
        to: Location,
    },

    /// `if …`
    If {
        condition: Condition,
        branches: Branch,
    },

    SetFlag {
        flag: Text,
    },
    UnsetFlag {
        flag: Text,
    },
    ReadFlag {
        flag: Text,
    },

    End,
}

impl Cmd {
    /// Human-readable names that correspond 1-to-1 to the numeric opcodes.
    pub const VARIANT_NAMES: &'static [&'static str] = &[
        "Msg",
        "TMsg",
        "Tp",
        "If",
        "SetFlag",
        "UnsetFlag",
        "ReadFlag",
        "End",
    ];

    /// Return the single-byte opcode for this command.
    #[inline(always)]
    pub fn opcode(&self) -> Opcode {
        match self {
            Cmd::Msg { .. } => Opcode::Msg,
            Cmd::TMsg { .. } => Opcode::TMsg,
            Cmd::Tp { .. } => Opcode::Tp,
            Cmd::If { .. } => Opcode::If,
            Cmd::SetFlag { .. } => Opcode::SetFlag,
            Cmd::UnsetFlag { .. } => Opcode::UnsetFlag,
            Cmd::ReadFlag { .. } => Opcode::ReadFlag,
            Cmd::End => Opcode::End,
        }
    }
}

/* ------------------------------------------------------------------------- */
/*  Byte-code generation                                                     */
/* ------------------------------------------------------------------------- */

/// Everything that can be put into the final byte-stream implements this trait.
pub trait ToBytecode {
    fn to_bytes(&self) -> Vec<u8>;
}

/* -------- Helper ---------- */

fn write_u16(v: u16, out: &mut Vec<u8>) {
    out.extend_from_slice(&v.to_le_bytes());
}

/* -------- Implementations -- */

impl ToBytecode for Text {
    fn to_bytes(&self) -> Vec<u8> {
        self.index.to_le_bytes().to_vec()
    }
}

impl ToBytecode for Location {
    fn to_bytes(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        match self {
            Location::Cords(x, y) => {
                buf.push(0); // variant tag
                write_u16(*x, &mut buf);
                write_u16(*y, &mut buf);
            }
            Location::Tag(t) => {
                buf.push(1);
                buf.extend_from_slice(&t.to_bytes());
            }
        }
        buf
    }
}

impl ToBytecode for Condition {
    fn to_bytes(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        match self {
            Condition::FlagSet(f) => {
                buf.push(0);
                buf.extend_from_slice(&f.to_bytes());
            }
            Condition::FlagClear(f) => {
                buf.push(1);
                buf.extend_from_slice(&f.to_bytes());
            }
        }
        buf
    }
}

impl ToBytecode for Branch {
    fn to_bytes(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        match self {
            Branch::ThenElse(then_cmd, else_cmd) => {
                buf.push(0);
                buf.extend_from_slice(&then_cmd.to_bytes());
                buf.extend_from_slice(&else_cmd.to_bytes());
            }
            Branch::Then(cmd) => {
                buf.push(1);
                buf.extend_from_slice(&cmd.to_bytes());
            }
        }
        buf
    }
}

impl ToBytecode for Cmd {
    fn to_bytes(&self) -> Vec<u8> {
        let mut buf = Vec::new();
        buf.push(u8::from(self.opcode())); // 1-byte discriminant

        match self {
            Cmd::Msg { text } => {
                buf.extend_from_slice(&text.to_bytes());
            }
            Cmd::TMsg { at, text } => {
                buf.extend_from_slice(&at.to_bytes());
                buf.extend_from_slice(&text.to_bytes());
            }
            Cmd::Tp { from, to } => {
                buf.extend_from_slice(&from.to_bytes());
                buf.extend_from_slice(&to.to_bytes());
            }
            Cmd::If {
                condition,
                branches,
            } => {
                buf.extend_from_slice(&condition.to_bytes());
                buf.extend_from_slice(&branches.to_bytes());
            }
            Cmd::SetFlag { flag } | Cmd::UnsetFlag { flag } | Cmd::ReadFlag { flag } => {
                buf.extend_from_slice(&flag.to_bytes());
            }
            Cmd::End => { /* nothing extra */ }
        }
        buf
    }
}

/* ------------------------------------------------------------------------- */
/*  Unit-tests                                                               */
/* ------------------------------------------------------------------------- */

#[cfg(test)]
mod tests {
    use super::*;

    // ──────────────────────────────────────────────────────────────────────
    //  Helpers
    // ──────────────────────────────────────────────────────────────────────

    fn txt(idx: u16, s: &str) -> Text {
        Text {
            text: s.into(),
            index: idx,
        }
    }

    // ──────────────────────────────────────────────────────────────────────
    //  Primitive types
    // ──────────────────────────────────────────────────────────────────────

    #[test]
    fn test_text_to_bytes() {
        let t = txt(0x1224, "dummy");
        assert_eq!(t.to_bytes(), vec![0x24, 0x12]); // little-endian
    }

    #[test]
    fn test_location_to_bytes() {
        // Cords
        let loc = Location::Cords(1, 2);
        assert_eq!(loc.to_bytes(), vec![0, 1, 0, 2, 0]);

        // Tag
        let loc = Location::Tag(txt(7, "tag"));
        assert_eq!(loc.to_bytes(), vec![1, 7, 0]);
    }

    // ──────────────────────────────────────────────────────────────────────
    //  Commands
    // ──────────────────────────────────────────────────────────────────────

    #[test]
    fn test_cmd_msg() {
        let cmd = Cmd::Msg { text: txt(3, "hi") };
        // opcode 0 (Msg) + text-index 3 (u16 LE)
        assert_eq!(cmd.to_bytes(), vec![0, 3, 0]);
    }

    #[test]
    fn test_cmd_tmsg_tag() {
        let cmd = Cmd::TMsg {
            at: Location::Tag(txt(1, "place")),
            text: txt(2, "hello"),
        };
        // opcode 1  | Location(Tag) => 1, idx 1  | text-idx 2
        assert_eq!(cmd.to_bytes(), vec![1, 1, 1, 0, 2, 0]);
    }

    #[test]
    fn test_cmd_tp_cords() {
        let cmd = Cmd::Tp {
            from: Location::Cords(1, 2),
            to: Location::Cords(3, 4),
        };
        // opcode 2
        //  from: 0, 1,0, 2,0
        //  to  : 0, 3,0, 4,0
        assert_eq!(cmd.to_bytes(), vec![2, 0, 1, 0, 2, 0, 0, 3, 0, 4, 0]);
    }

    #[test]
    fn test_cmd_setflag() {
        let cmd = Cmd::SetFlag {
            flag: txt(5, "flag"),
        };
        assert_eq!(cmd.to_bytes(), vec![4, 5, 0]); // opcode 4
    }
}
